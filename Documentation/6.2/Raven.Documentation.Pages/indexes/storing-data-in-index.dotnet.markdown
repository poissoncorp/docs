# Storing Data in Index
---

{NOTE: }

* RavenDB allows you to store data in a static index.

* When data is stored in the index, it can be retrieved directly from the index when querying the index and [projecting selected fields](../indexes/querying/projections),
  without requiring the server to load the original document from storage.  
  This behavior can be configured at the query level. See [Projection behavior with a static-index](../indexes/querying/projections#projection-behavior-with-a-static-index) for details.

* In this article:
  * [What content is stored in the index](../indexes/storing-data-in-index#what-content-is-stored-in-the-index)
  * [When and why to store data in an index](../indexes/storing-data-in-index#when-and-why-to-store-data-in-an-index)    
  * [Storing data in index - from the Client API](../indexes/storing-data-in-index#storing-data-in-index---from-the-client-api)
  * [Storing data in index - from the Studio](../indexes/storing-data-in-index#storing-data-in-index---from-the-studio)

{NOTE/}

---

{PANEL: What content is stored in the index}

* A static index is defined by its map function which determines the content of each **index-entry**.  
  Typically, a single index-entry is created for each document from the indexed source collection -  
  unless using a [Fanout index](../indexes/indexing-nested-data#fanout-index---multiple-index-entries-per-document), which produces multiple entries per document.

* Each index-entry consists of a set of **index-fields**, populated with values as defined in the map function.  
  The content of an index-field can be a direct value from the source document field,   
  or a computed value based on the source document's content.

* You can configure an [Analyzer](../indexes/using-analyzers) (either a custom one or one of RavenDBâ€™s built-in analyzers) to tokenize the content of an index-field for [Full-text search](../indexes/querying/searching).
  The tokens (terms) created by the analyzer form the searchable content of the index. When querying the index, you can filter documents based on these terms.

* **RavenDB allows you to store the original index-field value in the index**.  
  **This stored value is the raw content produced by the map function, BEFORE it is tokenized by the analyzer**.  
  * The tokens (terms) generated by the analyzer are searchable but not stored.
  * The index-field values, if explicitly marked as stored, are retrievable when [Projecting index query results](../indexes/querying/projections)  
    (by default they are not stored).

* This behavior is supported by both Lucene and Corax search engines.

{PANEL/}

{PANEL: When and why to store data in an index}

* **Store a field in the index if**:

  * **You want to project that field without loading the full document.**  
    Storing data in a static index allows RavenDB to retrieve that data directly from the index when projecting fields in a query, instead of loading the original document from storage.
    If all projected fields are stored, the document will not be loaded - values are fetched directly from the index, resulting in faster projections and better performance.
  * **The index-field is a computed value that you want to return in the query results.**  
    Normally, querying an index returns matching documents.
    But if you're projecting a computed index-field that is Not stored,
    you'll need to re-calculate the computed value manually from the documents returned by the query.  
    Storing the computed field avoids this extra step.

* **You do not need to store a field in the index in order to**:

  * Filter by the field in a query.
  * Perform full-text search on the field.

* **Disadvantage of storing data in the index**:

  * Increased disk space usage - stored fields take up additional space and increase index size.

{PANEL/}

{PANEL: Storing data in index - from the Client API}

To store an index-field in a static index, pass `FieldStorage.Yes` to the `Stores` method in the index definition.
The default is `FieldStorage.No`.

---

**Index example:**

{CODE-TABS}
{CODE-TAB:csharp:LINQ_index index_1@Indexes\Storing.cs /}
{CODE-TAB:csharp:JS_index index_2@Indexes\Storing.cs /}
{CODE-TAB:csharp:IndexDefinition index_3@Indexes\Storing.cs /}
{CODE-TABS/}

---

<a id="query-the-index" />
**Querying the index and projecting results:**

{CONTENT-FRAME: }

* In this query, the projected results are defined by the custom class `NumberOfItemsOrdered`.

* By default, the results will be retrieved from the index, because this class contains a single field `TotalItemsOrdered `, which is stored in the index.
  The server does Not need to load the original document from storage.  
  This behavior can be configured at the query level. See [Projection behavior with a static-index](../indexes/querying/projections#projection-behavior-with-a-static-index) for details.

{CODE-TABS}
{CODE-TAB:csharp:Query query_1@Indexes\Storing.cs /}
{CODE-TAB:csharp:Query_async query_1_async@Indexes\Storing.cs /}
{CODE-TAB:csharp:DocumentQuery query_1_docQuery@Indexes\Storing.cs /}
{CODE-TAB:csharp:DocumentQuery_async query_1_docQuery_async@Indexes\Storing.cs /}
{CODE-TAB:csharp:Projection_class details_to_project_1@Indexes\Storing.cs /}
{CODE-TAB-BLOCK:sql:RQL}
from index "QuantityOrdered/ByCompany"
where Company = "companies/90-A"
select TotalItemsOrdered
{CODE-TAB-BLOCK/}
{CODE-TABS/}

{CONTENT-FRAME/}
{CONTENT-FRAME: }

* In this query, the projected results are defined by the custom class `ProjectedDetails`.
 
* In this case, some of the fields in this class are Not stored in the index, so by default,
  the server does need to load the original document from storage to complete the projection.  
  This behavior can be configured at the query level. See [Projection behavior with a static-index](../indexes/querying/projections#projection-behavior-with-a-static-index) for details.

{CODE-TABS}
{CODE-TAB:csharp:Query query_2@Indexes\Storing.cs /}
{CODE-TAB:csharp:Query_async query_2_async@Indexes\Storing.cs /}
{CODE-TAB:csharp:DocumentQuery query_2_docQuery@Indexes\Storing.cs /}
{CODE-TAB:csharp:DocumentQuery_async query_2_docQuery_async@Indexes\Storing.cs /}
{CODE-TAB:csharp:Projection_class details_to_project_2@Indexes\Storing.cs /}
{CODE-TAB-BLOCK:sql:RQL}
from index "QuantityOrdered/ByCompany"
where Company = "companies/90-A"
select Company, OrderedAt, TotalItemsOrdered
{CODE-TAB-BLOCK/}
{CODE-TABS/}
{CONTENT-FRAME/}

{PANEL/}

{PANEL: Storing data in index - from the Studio}

To configure index-fields from the Studio, open the _Edit Index_ view:

![The index](images/store-field-in-index-1.png)

1. This is the index from the [example above](../indexes/storing-data-in-index#storing-data-in-index---from-the-client-api).
2. These are the index-fields defined in the index map function.

---

Scroll down to configure each index-field:

![Configure index fields](images/store-field-in-index-2.png)

1. Open the _Fields_ tab.
2. Enter the name of the index-field. Here we configure index-field `TotalItemsOrdered`.
3. Select _Yes_ from the dropdown to store the field in the index.
4. Here we configure index-field `CompanyName`.
5. This index-field is configured to be stored in the index,
   and is also configured for full-text search.

---

When querying the index from the Studio,  
you can choose to display the stored index fields in the Results view:

![Display the stored fields](images/store-field-in-index-3.png)

1. This is the query from the [example above](../indexes/storing-data-in-index#query-the-index).
2. Open the _Settings_ options.
3. Toggle ON _Show stored index fields only_.
4. When executing the query,  
   the results will display the stored index-fields for each object returned by the query.  

{PANEL/}

## Related Articles

### Indexes

- [Analyzers](../indexes/using-analyzers)
- [Projection behavior with a static-index](../indexes/querying/projections#projection-behavior-with-a-static-index)
